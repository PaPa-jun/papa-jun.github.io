#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 100
#define MAX_label_LENGTH 20
#define OPCODE_LENGTH 4
#define INSTRUCTION_NUM 24

//The data structure of label
typedef struct label
{
    char name[20];    //The name of label
    unsigned short address;    //The address of label
}LABEL;

//The data structure of symbol table
typedef struct label_table
{
    unsigned short start;    //The start address of the whole program
    LABEL table[30];    //Symbol table
    int num;    //The number of labels
}TABLE;

//The data structure of instructions
typedef struct INSTRUCTION
{
    char ASM[7];
    char Opcode[5];
}Instructions;

TABLE SymbolTable;    //Symbol Table
//LC-3 ISA
Instructions instructions[INSTRUCTION_NUM] = {{"LEA", "1110"}, {"ADD", "0001"}, {"AND", "0101"}, {"JMP", "1100"}, {"JSR", "0100"}, {"JSRR", "0100"}, {"BR", "0000"}, {"BRZ", "0000"}, {"BRP", "0000"}, {"BRN", "0000"}, {"BRNZ", "0000"}, {"BRNP", "0000"}, {"BRZP", "0000"}, {"BRNZP", "0000"}, {"LD", "0010"}, {"LDI", "1010"}, {"LDR", "0110"}, {"NOT", "1001"}, {"RET", "1100"}, {"RTI", "1000"}, {"ST", "0011"}, {"STI", "1011"}, {"STR", "0111"}, {"TRAP", "1111"}};
unsigned short PC;    //PC
int difference = 0;    //The difference generated by the processing of ".STRINGZ" pesudo

// Function prototypes
void read_asm_file(const char *filename, char lines[][MAX_LINE_LENGTH], int *num_lines);
void write_output_file(const char *filename, const char *output[], int num_lines);
void assemble(char lines[][MAX_LINE_LENGTH], int num_lines, char *output[]);
void translate_instruction(const char *instruction, char *machine_code);
unsigned short transform(const char input[], char output[], int expend);
int Find_label(char instruction[]);
int OnepartRead(const char* instruction , char output[], int index);
void SplitNumber(int target, char result[]);
void Instruction_BR(const char instruction[], char machine_code[], int index);
void Instrucion_Pseudo(const char instruction[], char machine_code[], char Part[], int index);
void Instrucion_ADDAND(const char instruction[], char machine_code[], int index);
void Instrucion_LS(const char instruction[], char machine_code[], char Part[],int index);

// TODO: Define any additional functions you need to implement the assembler, e.g. the symbol table.

int main(int argc, char *argv[])
{
    // Command-line argument parsing
    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s <input_file.asm> <output_file.txt>\n", argv[0]);
        return 1;
    }

    char input_filename[100];
    char output_filename[100];
    strcpy(input_filename, argv[1]);
    strcpy(output_filename, argv[2]);

    char lines[100][MAX_LINE_LENGTH]; // Assuming a maximum of 100 lines
    int num_lines = 0;
    read_asm_file(input_filename, lines, &num_lines);

    char *output[100]; // Output array of strings
    for (int i = 0; i < 100; i++)
    {
        output[i] = (char *)malloc(MAX_LINE_LENGTH * sizeof(char));
    }

    assemble(lines, num_lines, output);
    write_output_file(output_filename, (const char **)output, num_lines + difference);    //Because one ".STRINGZ" or ".BLKW" instruction can take more than one location

    // Free allocated memory
    for (int i = 0; i < 100; i++)
    {
        free(output[i]);
    }

    return 0;
}

void read_asm_file(const char *filename, char lines[][MAX_LINE_LENGTH], int *num_lines)
{
    FILE *file = fopen(filename, "r");
    if (file == NULL)
    {
        fprintf(stderr, "Unable to open file: %s\n", filename);
        exit(1);
    }

    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file))
    {
        strcpy(lines[*num_lines], line);
        (*num_lines)++;
    }

    fclose(file);
}

void write_output_file(const char *filename, const char *output[], int num_lines)
{
    FILE *file = fopen(filename, "w");
    if (file == NULL)
    {
        fprintf(stderr, "Unable to open file: %s\n", filename);
        exit(1);
    }

    for (int i = 0; i < num_lines; i++)
    {
        fprintf(file, "%s\n", output[i]);
    }

    fclose(file);
}

void assemble(char lines[][MAX_LINE_LENGTH], int num_lines, char *output[])
{
    int index = 0;    //The position of the instruction reading point
    int index_table = 0;
    char temp[100];
    
    //First pass to build the Symble table
    PC = -1;
    for (int i = 0 ; i < num_lines; i++){
        if (Find_label(lines[i])){
            index = OnepartRead(lines[i], SymbolTable.table[index_table].name, 0);
            SymbolTable.table[index_table].address = PC;
            index_table++;
        }
        index = OnepartRead(lines[i], temp, index);
        if (!strcmp(temp, ".STRINGZ")){
            for (int j = index ; lines[i][j] != '\0' && lines[i][j] != '\n' ; j++){
                if (lines[i][j] == '"') continue;
                PC++;
            }
        }//incrament the pc depending on the strings
        if (!strcmp(temp, ".BLKW")){
            int number;
            char N[0];
            index = OnepartRead(lines[i], temp, index);
            number = transform(temp, N, 0);
            for (int j = 1 ; j < number ; j++){
                PC++;
            }
        }//e.g. .BLKW 3
        PC++;
    }
    SymbolTable.num = index_table;    //Record the number of labels

    //Second pass
    //To translate every single instruction

    PC = -1;
    for (int i = 0; i < num_lines; i++)
    {
        //Because the ".STRINGZ" pesudo and ".BLKW" pesudo may take more than one location in memory so it has to be done out of the translate_instruction function
        for (int j = 0 ; j < 16 ; j++){
            //Check if lines[i] is a pesudo instruction
            if (lines[i][j] == '.'){
                index = OnepartRead(lines[i], temp, j);
                if (!strcmp(temp, ".STRINGZ")){
                    int k;
                    //Tranvers the data of .STRINGZ and store the corresponding info
                    for (k = index ; lines[i][k] != '\0' && lines[i][k] != '\n' ; k++){
                        if (lines[i][k] == '"') continue;
                        SplitNumber((int)lines[i][k], temp);
                        transform(temp, output[i + difference++], 16);
                    }
                    break;
                }
                if (!strcmp(temp, ".BLKW")){
                    int num;
                    char N[100];
                    index = OnepartRead(lines[i], temp, index);
                    num = transform(temp, N, 0);
                    //Sotre 0 into memory depending on the .BLKW num
                    for (int k = 1 ; k < num ; k++){
                        transform("#0", output[i + difference++], 16);
                    }
                    break;
                }
                break;
            }
        }
        translate_instruction(lines[i], output[i + difference]);
        PC++;
    }
}

void translate_instruction(const char *instruction, char *machine_code)
{
    char Part[100];    //One part of a instruction
    int index = 0;    //The index will be used in reading every part of the instruction
    char temp[100];    //Temp data
    char number[100];    //Some numbers
    
    //Initial the machine_code
    for (int i = 0 ; i < 100 ; i++){
        machine_code[i] = 0;
    }

    //Read the first part of a instruction and record the end position of this reading
    index = OnepartRead(instruction, Part, index);

    //If it is a .ORIG or .END
    if (Part[0] == '.'){
        Instrucion_Pseudo(instruction, machine_code, Part, index);
        return ;
    }

    //If the the first part of the instruction is a label
    for (int i = 0 ; i < SymbolTable.num ; i++){
        if (!strcmp(Part, SymbolTable.table[i].name)){
            //If the first part of the instruction ia a label, read one more part to ignore the label
            index = OnepartRead(instruction, Part, index);
            break;
        }
    }

    //If the first part of the instruction ia a opcode (e.g. ADD)
    for (int i = 0 ; i < INSTRUCTION_NUM ; i++){
        if (!strcmp(Part, instructions[i].ASM)){
            //Add the opcode into the output
            strcat(machine_code, instructions[i].Opcode);
            break;
        }
    }

    //If the instruction is a BR instruction
    if (Part[0] == 'B' && Part[1] == 'R'){
        strcat(machine_code, "000");    //Inite the condition code
        Instruction_BR(instruction, machine_code, index);
        return ;
    }
    
    //If the instruction is a pesudo instruction
    if (Part[0] == '.'){
        Instrucion_Pseudo(instruction, machine_code, Part, index);
        return ;
    }

    //ADD or AND
    if (Part[0] == 'A'){
        Instrucion_ADDAND(instruction, machine_code, index);
        return ;
    }

    //The instruction is a load or store instruction
    if (Part[0] == 'L' || Part[0] == 'S'){
        Instrucion_LS(instruction, machine_code, Part, index);
        return ;
    }

    //NOT instruction
    if (Part[0] == 'N'){
        for (int i = 0 ; i < 2 ; i++){
            index = OnepartRead(instruction, Part, index);
            transform(Part, temp, 3);
            strcat(machine_code, temp);
        }
        strcat(machine_code, "111111");
        return ;
    }

    //RET instruction
    if (!strcmp(Part, "RET")){
        strcat(machine_code, "000111000000");
        return ;
    }

    //RTI instruction
    if (!strcmp(Part, "RTI")){
        strcat(machine_code, "000000000000");
        return ;
    }

    //TRAP instruction
    if (Part[0] == 'T'){
        strcat(machine_code, "0000");
        index = OnepartRead(instruction, Part, index);
        transform(Part, temp, 8);
        strcat(machine_code, temp);
        return ;
    }

    //JMP or JSRR (They have the same format)
    if (!strcmp(Part, "JMP") || !strcmp(Part, "JSRR")){
        strcat(machine_code, "000");
        index = OnepartRead(instruction, Part, index);
        transform(Part, temp, 3);
        strcat(machine_code, temp);
        strcat(machine_code, "000000");
        return ;
    }

    //JSR
    if (!strcmp(Part, "JSR")){
        strcat(machine_code, "1");
        index = OnepartRead(instruction, Part, index);
        if (Part[0] == '#' || Part[0] == 'x'){
            transform(Part, temp, 11);
            strcat(machine_code, temp);
        }else{
            for (int i = 0 ; i < SymbolTable.num ; i++){
                if (!strcmp(Part, SymbolTable.table[i].name)){
                    SplitNumber(SymbolTable.table[i].address - (PC + 1), number);
                    transform(number, temp, 11);
                    strcat(machine_code, temp);
                }
            }
        }
        return ;
    }
}

//Deal with BR instruction
void Instruction_BR(const char instruction[], char machine_code[], int index){
    char Part[100];
    char temp[100];
    char number[100];

    //Read the BR part of the instruction
    Part[0] = Part[1] = Part[2] = Part[3] = Part[4] = 0;
    index = 0;
    if (Part[0] != 'B' || Part[1] != 'R'){
        index = OnepartRead(instruction, Part, index);
    }

    //Update the condition code
    for (int i = 2 ; i <= 4; i++){
        switch (Part[i])
        {
        case 'N' :
            machine_code[4] = '1';
            break;
        case 'Z' :
            machine_code[5] = '1';
            break;
        case 'P' :
            machine_code[6] = '1';
        default:
            break;
        }
    }

    //Deal with the PC-offset
    index = OnepartRead(instruction, Part, index);
    if (Part[0] == '#' || Part[0] == 'x'){
        //IMM
        transform(Part, temp, 9);    //Convert to binary
        strcat(machine_code, temp);    //Update the output
    }else{
        //label
        for (int i = 0 ; i < SymbolTable.num ; i++){
            if (!strcmp(Part, SymbolTable.table[i].name)){
                SplitNumber(SymbolTable.table[i].address - (PC + 1), number);    //Calculate the offset and store as an array
                transform(number, temp, 9);    //Convert the number to binary
                strcat(machine_code, temp);    //Update the output
                break;
            }
        }
    }
}

//Deal with the pseudo
void Instrucion_Pseudo(const char instruction[], char machine_code[], char Part[], int index){
    char temp[100];
    int number;
    char N[100];
    if (!strcmp(Part, ".FILL")){
        //Read the content beside the .FILL
        OnepartRead(instruction, Part, index);
        if (Part[0] == 'x' || Part[0] == '#'){
            //If the content is a number (address)
            transform(Part, machine_code, 16);
            return ;
        }else{
            //If the content is a label
            for (int i = 0 ; i < SymbolTable.num ; i++){
                if (!strcmp(Part, SymbolTable.table[i].name)){
                    SplitNumber(SymbolTable.start + SymbolTable.table[i].address, temp);    //Calculate the address of that label
                    transform(temp, machine_code, 16);
                    return ;
                }
            }
        }
    }
    if (!strcmp(Part, ".BLKW")){
        //Add one more NULL
        strcat(machine_code, "0000000000000000");
        return ;
    }
    if (!strcmp(Part, ".STRINGZ")){
        //Add the '\0' at the end of the strings
        strcat(machine_code, "0000000000000000");
        return ;
    }
    if (!strcmp(Part, ".ORIG")){
        //Read the address and record it
        OnepartRead(instruction, Part, index);
        SymbolTable.start = transform(Part, machine_code, 16);
        return ;
    }
    if(!strcmp(Part, ".END")){
        return ;
    }
}

//Translate the ADD and AND instructions
void Instrucion_ADDAND(const char instruction[], char machine_code[], int index){
    char Part[100];
    char temp[100];
    int IMM = 3;    //If the last oprand of the instruction is a IMM, IMM == 5. If it is a register, IMM == 3

    //Read one more part of the instruction for three times
    for (int i = 0 ; i < 3 ; i++){
        index = OnepartRead(instruction, Part, index);
        //If it is the last oprand
        if (i == 2){
            if (Part[0] == 'R'){
                strcat(machine_code, "000");    //If it is a register
            }else{
                strcat(machine_code, "1");    //if it is a IMM
                IMM = 5;
            }
        }
        transform(Part, temp, IMM);
        strcat(machine_code, temp);    //Update the output
    }
}

//Translate the LOAD and STORE instructions
void Instrucion_LS(const char instruction[], char machine_code[], char Part[],int index){
    char temp[100];
    char number[100];
    
    if (Part[2] == 'R'){
        //If the instruction is LDR ot STR
        //Read one more part of the instruction for twice
        for (int i = 0 ; i < 2 ; i++){
            index = OnepartRead(instruction, Part, index);
            transform(Part, temp, 3);
            strcat(machine_code, temp);
        }
        //Read the PC-Offset
        index = OnepartRead(instruction, Part, index);
        transform(Part, temp, 6);
        strcat(machine_code, temp);
        return ;
    }else{
        //The instruction is LD LDI ST or STI
        index = OnepartRead(instruction, Part, index);
        transform(Part, temp, 3);
        strcat(machine_code, temp);
        index = OnepartRead(instruction, Part, index);
        if (Part[0] == '#' || Part[0] == 'x'){
            //If the last part is a IMM
            transform(Part, temp, 9);
            strcat(machine_code, temp);
            return ;
        }else{
            //A label
            for (int i = 0 ; i < SymbolTable.num ; i++){
                if (!strcmp(Part, SymbolTable.table[i].name)){
                    SplitNumber(SymbolTable.table[i].address - (PC + 1), number);
                    transform(number, temp, 9);
                    strcat(machine_code, temp);
                    return ;
                }
            }
        }
    }
}

//Convert a decimao or hex number into binary and sotre as an array, return the unsigned type
unsigned short transform(const char input[], char output[], int expend){
    int index = 0;
    unsigned short Input = 0;    //16 bits to calculate the complement
    //Convert the number in array to a unsinged shor number which can easily calculate
    if (input[index++] == 'x'){
        //Hex
        if (input[index++] == '-'){
            //Mius
            for (int i = index ; input[i] != ' ' && input[i] != '\0' && input[i] != '\n' && input[i] != ','; i++){
                if (input[i] >= 'A'){
                    Input = Input * 16 - (input[i] - 'A' + 10);
                }else{
                    Input = Input * 16 - (input[i] - '0');
                }
            }
        }else{
            index--;
            for (int i = index ; input[i] != ' ' && input[i] != '\0' && input[i] != '\n' && input[i] != ','; i++){
                if (input[i] >= 'A'){
                    Input = Input * 16 + (input[i] - 'A' + 10);
                }else{
                    Input = Input * 16 + (input[i] - '0');
                }
            }
        }
    }else{
        //Decimal from IMM or register
        if (input[index - 1] != '#' && input[index - 1] != 'R') index--;
        if (input[index++] == '-'){
            for (int i = index ; input[i] != ' ' && input[i] != '\0' && input[i] != '\n' && input[i] != ','; i++){
                Input = Input * 10 - (input[i] - '0');
            }
        }else{
            index--;
            for (int i = index ; input[i] != ' ' && input[i] != '\0' && input[i] != '\n' && input[i] != ','; i++){
                Input = Input * 10 + (input[i] - '0');
            }
        }
    }
    
    unsigned short temp = Input;
    char Temp[100];
    int i = 0;
    do    //Convert to binary
    {
        Temp[i] = (temp%2) + '0';
        temp = temp / 2;
        i++;
    } while (i < 16);
    
    //Store the result
    for (i = 0 ; i < expend ; i++){
        output[expend - 1 - i] = Temp[i];
    }
    output[i] = '\0';

    return Input;
}

//Judge if a part of an instruction ia a label
int Find_label(char instruction[]){
    char part[20];
    OnepartRead(instruction, part, 0);
    
    int flag = 1;
    //Tranvers the LC-3 ISA
    for (int i = 0 ; i < INSTRUCTION_NUM ; i++){
        if(!strcmp(part, instructions[i].ASM)){
            flag = 0;
            break;
        }
    }

    return flag;
}

//Read one part of a instruction (between tow space characters)
int OnepartRead(const char* instruction , char output[], int index){
    int i;
    for (i = index;  instruction[i] != ' ' && instruction[i] != '\0' && instruction[i] != '\n'; i++){
        output[i - index] = instruction[i];
    }
    output[i - index] = '\0';
    return i+1;
}

//Split a integer number, store as an array
void SplitNumber(int target, char result[]){
    char temp[100];
    int index = 0;
    result[index++] = '#';
    if (target < 0){
        result[index++] = '-';
        target = - target;
    }
    int i = 0;
    do
    {
        temp[i++] = target % 10 + '0';
        target = target / 10;
    } while (target > 0);
    
    for (int j = index; j < index + i; j++){
        result[index++] = temp[--i];
    }
    result[index] = '\0';
}